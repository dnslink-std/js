const test = require('fresh-tape')
const { reducePath } = require('.')

test('reducePath', async t => {
  t.equals(reducePath('foo', []), 'foo', 'Simple pass through')
  t.equals(reducePath('foo#bar', []), 'foo', 'Hash values are not supported')
  t.equals(reducePath('foo?bar=baz&bar=boo&bak=booz', []), 'foo?bar=baz&bar=boo&bak=booz', 'Pass through of some query values.')
  t.equals(reducePath('テスト ?日本語=言語', []), '%E3%83%86%E3%82%B9%E3%83%88%20?%E6%97%A5%E6%9C%AC%E8%AA%9E=%E8%A8%80%E8%AA%9E', 'Unicode is converted to URI encoded')
  t.equals(reducePath('foo/../bar/baz/../boo', []), 'bar/boo', 'Input paths are reduced')
  t.equals(reducePath('foo', [{ pathname: '/baz' }]), 'foo/baz', 'Concatinating simple paths')
  t.equals(reducePath('foo', [{ pathname: '//baz' }]), 'baz', 'Concatinating absolute paths')
  t.equals(reducePath('foo', [{ pathname: '/bar' }, { pathname: '/baz' }]), 'foo/bar/baz', 'Concatinating path entries from first to last')
  t.equals(reducePath('foo?kuu=moo', [{ search: { bar: ['baz', 'boo'] } }]), 'foo?kuu=moo&bar=baz&bar=boo', 'Concatinating search queries')
  t.equals(reducePath('foo/../bar/baz/../boo', [{ pathname: '/../zoo/doo/./moo' }, { pathname: '/./kee/../koo/soo' }]), 'bar/zoo/doo/moo/koo/soo', 'Combining and reducing . and .. entries')
  t.equals(reducePath('foo', [{ pathname: '/bar', search: { boo: ['mee', 'moo'] } }, { pathname: '/baz' }, { search: { kuu: ['kee', 'koo'] } }]), 'foo/bar/baz?boo=mee&boo=moo&kuu=kee&kuu=koo', 'Multiple search and pathname combinations.')
})
